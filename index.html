<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Timeline - Inline Styles</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: "Segoe UI", Roboto, "Noto Sans KR", sans-serif; padding: 20px; background:#fff; }
    .chart-container { display:flex; justify-content:center; }
    svg { overflow: visible; }
  </style>
</head>
<body>
  <h2>타임라인 (인라인 스타일 적용)</h2>
  <div class="chart-container">
    <svg id="timeline-chart" width="1000" height="360"></svg>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const data = [
        { label: '대학교 교양수업으로 Java 배우기', startDate: new Date(2000,0,1) },
        { label: '2017년 춘계학술발표대회 학부생 논문경진대회 – 금상', startDate: new Date(2000,0,2) },
        { label: 'Unity를 활용한 VR/AR 교육 (160시간)', startDate: new Date(2000,0,3) },
        { label: 'JAVA 웹개발 스택 교육과정 수료', startDate: new Date(2000,0,4) },
        { label: '운 좋게 바로 JAVA 개발자로 취뽀 성공', startDate: new Date(2000,0,5) },
        { label: '웹 개발의 처음과 끝을 완성해보다.', startDate: new Date(2000,0,6) },
        { label: '나라는 존재를 개발 세상에 알리는 중!', startDate: new Date(2000,0,7) }
      ];

      const width = 900, height = 300;
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
      const effectiveWidth = width * 0.9; // spacing multiplier 적용 예시
      const timelineY = (height - margin.top - margin.bottom) / 2 + margin.top;

      // root SVG
      const svgRoot = d3.select("#timeline-chart")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

      // defs MUST be in the same svg
      const defs = svgRoot.append("defs");
      const grad = defs.append("linearGradient")
        .attr("id", "timeline-gradient")
        .attr("gradientUnits", "userSpaceOnUse") // 중요: 픽셀 좌표계로 그라데이션 적용
        .attr("x1", 0).attr("y1", 0)
        .attr("x2", effectiveWidth).attr("y2", 0);
      grad.append("stop").attr("offset","0%").attr("stop-color","#28a745");
      grad.append("stop").attr("offset","33%").attr("stop-color","#ffc107");
      grad.append("stop").attr("offset","66%").attr("stop-color","#dc3545");
      grad.append("stop").attr("offset","100%").attr("stop-color","#6f42c1");

      // 그룹(마진 적용)
      const svg = svgRoot.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      // x scale
      const xScale = d3.scaleTime()
        .domain([d3.min(data, d=>d.startDate), d3.max(data, d=>d.startDate)])
        .range([0, effectiveWidth]);

      // 메인 타임라인 (그라데이션) - 인라인 스타일로 적용
      const mainLine = svg.append("line")
        .attr("x1", 0).attr("y1", timelineY - margin.top)
        .attr("x2", effectiveWidth).attr("y2", timelineY - margin.top)
        .attr("stroke-width", 8)
        .attr("stroke-linecap", "round")
        // 인라인 스타일로 그라데이션 참조 (브라우저/DevTools에서 CSS reference 문제 안 생김)
        .style("stroke", "url(#timeline-gradient)")
        .style("opacity", 1);

      // 색상 배열 (점용)
      const colors = ["#ffc107", "#007bff", "#28a745", "#dc3545", "#6f42c1", "#e83e8c", "#fd7e14"];

      // 점들 사이 연결선 (단색) — 역시 인라인 스타일로 지정
      for (let i = 1; i < data.length; i++) {
        svg.append("line")
          .attr("x1", xScale(data[i-1].startDate))
          .attr("y1", timelineY - margin.top)
          .attr("x2", xScale(data[i].startDate))
          .attr("y2", timelineY - margin.top)
          .attr("stroke-width", 2)
          .attr("stroke-linecap", "round")
          .style("stroke", "#888") // 인라인 스타일
          .style("opacity", 0.9);
      }

      // 그룹으로 원과 텍스트 추가
      const groups = svg.selectAll(".item")
        .data(data)
        .enter()
        .append("g")
        .attr("class", "item");

      // 원 (인라인 stroke/fill)
      groups.append("circle")
        .attr("cx", d => xScale(d.startDate))
        .attr("cy", timelineY - margin.top)
        .attr("r", 7)
        .attr("fill", (d,i) => colors[i % colors.length])
        .attr("stroke", "#333")
        .attr("stroke-width", 1.2);

      // 라벨 (회전)
      const rotationAngle = -45;
      groups.append("text")
        .attr("x", d => xScale(d.startDate))
        .attr("y", timelineY - margin.top - 12)
        .text(d => d.label)
        .attr("text-anchor", "start")
        .attr("dominant-baseline", "hanging")
        .style("font-size", "13px")
        .style("fill", (d,i) => colors[i % colors.length])
        .attr("transform", function(d) {
          const x = xScale(d.startDate);
          const y = timelineY - margin.top - 12;
          return `rotate(${rotationAngle}, ${x}, ${y})`;
        })
        .attr("pointer-events", "none");

      // (디버그용) 빠르게 단색으로 보이는지 확인하고 싶다면 아래 주석 해제
      // svg.append("line").attr("x1",0).attr("y1",timelineY- margin.top + 20).attr("x2",effectiveWidth).attr("y2",timelineY- margin.top + 20).style("stroke","red").attr("stroke-width",4);
    });
  </script>
</body>
</html>